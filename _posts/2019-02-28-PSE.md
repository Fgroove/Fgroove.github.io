---
layout: post
title:  "PSE"
date:   2019-02-28 14:55:01 +0800
categories: 基于动态的恶意软件分析
tag: 反沙箱对抗技术
---
* content
{:toc}


# 2019-02-28-Eliminating-Path-Redundancy-via-Postconditioned-Symbolic-Execution

*Eliminating Path Redundancy via Postconditioned Symbolic Execution, TES'2018*

## Abstract

* **问题：**符号执行受到路径爆炸（path explosion）的限制，因为程序的路径数量可以是执行期间遇到的分支条件的数量的指数级别。

* **贡献：**我们提出了一种称为后处理符号执行（PSE）的新冗余删除方法。

  在每个分支位置，除了确定特定分支在传统符号执行中是否可行之外，还检查分支是否被先前的探索所包含。这是通过最弱的前提条件（WP）计算总结先前探索的路径来实现的。

  后处理符号执行可以识别多个运行路径共享的路径后缀，当它们冗余时在测试生成期间消除它们。修剪掉这些冗余路径可能导致探索路径数量的潜在指数减少。

  由于新方法的计算成本很高，我们还提出了几种启发式方法来降低其成本。

* **论证：**我们在符号执行引擎KLEE中实现了我们的方法，并对GNU Coreutils套件中的大量程序进行了实验。

  我们的结果证实，由于共同路径后缀导致的冗余在实际应用中既丰富又广泛。

  

## 1 INTRODUCTION

由于其在本地执行环境中处理实际应用程序的能力，动态符号执行在实际环境中非常成功 — 对于相关工具的概述，请参阅Pasareanu等人。【[1](http://ix.cs.uoregon.edu/~michal/cis507/PasareanuVisser-SurveyNewTrendsSymbolicExecution.pdf)】

阻止符号执行得到更广泛应用的一个主要障碍是路径爆炸。即，程序的路径数量可以是执行期间遇到的分支条件数量的指数。即使对于中等规模的程序和小范围执行深度，详尽地覆盖所有可能的路径也是非常昂贵的。

### 示例

考虑图1中的程序，它有三个输入变量a，b，c和三个连续的if-else语句。

动态符号执行能够计算一组测试输入，每个测试输入都具有所有输入变量的具体值，以详尽地覆盖程序的有效执行路径。这个程序有2^3 = 8个不同的执行路径。经典的符号执行工具（如KLEE ）将生成8个测试输入。

本例的覆盖路径编号为1到8，如图1（右）所示。例如，P1是通过第1行的if-branch，第3行的if-branch和第5行的if-branch的路径。

![1](/Users/saris/Documents/GitHub Pages/Fgroove.github.io/styles/images/dynamic_Analysis/sandbox/1.png)

---

目前已经有许多工作来缓解路径爆炸问题。其中一个在实践中非常有效，被称为预处理符号执行。除了被测程序之外，它还通过将预定义约束 $\prod_{prec}$ 作为附加参数来实现路径减少。预处理符号执行仅执行满足$\prod_{prec}$的程序分支，具有修剪掉不符合条件的后续分支的实际效果。

通过利用约束，预处理符号执行有效地减少了搜索空间。即，通过牺牲符号执行的完整性来实现路径减少。例如，通过将$\prod_{prec}$设置为false，预处理符号执行终止而不探索任何路径。

---

在本文中，假设所有潜在的错误都被建模为条件中止语句，我们提出了一种称为后处理符号执行的新方法，它可以**在不减少搜索空间的情况下消除冗余路径**。新方法通过识别并消除符号执行期间遇到的冗余路径后缀来减轻路径爆炸。

我们的方法是基于观察到不同的测试运行之间共享许多路径后缀，反复探索这些路径后缀是路径爆炸的主要原因。

再次考虑图1。尽管图1中的八条路径不同，但它们共享共同的路径后缀。例如，后缀 $\cdots\to$ 3 $\to$ 5路径，由1号和5号路径共用；而后缀$\cdots\to$6路径由2号，4号，6号和8号路径共享。当然，共享后缀并不一定意味着不需要再次探索。否则，路径探索将被错误地减少为分支覆盖。另一方面，由于测试的目的是发现错误（bugs），一旦路径后缀不会显示任何新的程序行为，我们不应该再次探索它。



