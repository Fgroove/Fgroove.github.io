---
layout: post
title:  Driller
date:   2019-03-11 8:55:01 +0800
categories: 基于动态的恶意软件分析
tag: 反沙箱对抗技术
---
* content
{:toc}


# Driller

---

Driller通过结合fuzzing的速度和符号执行输入生成能力实现功能。

## 3 Overview

### 2类输入
---
* General input
* Special input

### Driller's Components
---
#### Input test cases. 
* Driller不需要输入测试案例，但是这些测试案例可以加速fuzzing的初始化。

#### Fuzzing
* 启动Driller，首先启动一个fuzzer，探索第一个ACom，到达第一个`complex check`，`stuck`无法继续搜索新的路径。

```plain
What is Application Compartment (ACom)？

An ACom of an application is a subset of a ROBAC where only the users, permissions, roles, and organizations applicable to the application are included.

Role and Organization Based Access Control (ROBAC)
```

#### Concolic Execution
* Fuzzer进入`stuck`时，Driller启动符号执行部分；符号执行分析应用，根据上一步Fuzzing得到的输入值来限制用户输入，从而避免路径爆炸。

根据fuzzer得到的输入，符号执行优化`constraint solver`，识别执行未探索过的路径的输入。

#### Repeat
一旦符号执行发现新的输入，立即传递回Fuzzing部分。

Fuzzing部分根据这些输入产生变异，模糊执行新的ACom。

Driller在Fuzzing和符号执行之间循环执行，直到发现导致Crash的输入。


## 4 Fuzzing
模糊测试是一种使用大量输入执行应用程序的技术，检查这些输入是否会导致应用程序崩溃。 为了保持执行速度，模糊器是最小的 - 它们对底层应用程序执行最少的检测，并且主要从外部监视它。
近年来，对模糊引擎进行了许多改进。 在本节中，我们将详细介绍与Driller性能相关的改进。


为了实现Driller，我们利用了一种流行的现成模糊器，即American Fuzzy Lop（AFL）[31]。 我们的改进主要涉及将模糊器与我们的concolic执行引擎集成。 没有改变AFL的逻辑。 AFL依靠仪器来做出有关哪条路径感兴趣的明智决策。 该工具可以在编译时引入，也可以通过修改后的QEMU引入[2]，我们选择了QEMU后端来消除对源代码可用性的依赖。 虽然我们在本节中讨论了Driller的模糊组件AFL的重要特性，但我们并未声称它们的发明或实施。

### A. Fuzzer功能
现代模糊器实现了许多功能，可以更好地识别崩溃输入。在本节中，我们将列出并描述最重要的AFL功能，并提及Driller如何使用它们。


**遗传模糊：** AFL通过遗传算法进行输入生成，根据遗传学启发的规则（转录，插入等）改变输入并通过适应度函数对它们进行排序。对于AFL，适应度函数基于唯一代码覆盖 - 即，触发与其他输入触发的路径不同的执行路径。

**状态转换跟踪：** AFL跟踪它从输入中看到的控制流转换的并集，作为源和目标基本块的元组。基于发现新的控制流转换，输入被优先用于遗传算法中的“育种”，这意味着导致应用以不同方式执行的输入在未来输入的生成中获得优先权。

**循环“bucketization”：** 处理循环是模糊引擎和类似执行引擎的复杂问题。为了帮助减小循环的路径空间的大小，执行以下启发式操作。当AFL检测到路径包含循环的迭代时，将触发二次计算以确定该路径是否有资格进行繁殖。 AFL确定执行的循环迭代次数，并将其与导致路径经过同一循环的先前输入进行比较。这些路径都通过其循环迭代计数的对数（即，1,2,4,8等）放入“桶”中。在遗传算法中考虑来自每个桶的一条路径用于育种。这样，对于每个循环，只考虑log（N）路径，而不是N路径的朴素方法。

**去随机化：** 程序随机化干扰了遗传模糊器对输入的评估 - 在给定的随机种子下产生有趣路径的输入可能不会在另一个下产生。我们将AFL的QEMU后端预先设置为特定的随机种子，以确保一致的执行。稍后，当发现崩溃输入时，我们使用我们的concoic执行引擎来恢复任何依赖于泄漏随机性的“质询 - 响应”行为或漏洞。例如，二进制文件中的“质询 - 响应”过程将随机数据回送给用户，并期望相同的数据回显给它。在不删除随机化的情况下，模糊测试组件每次都可能无法通过此检查并探索很少的路径。如果随机性是恒定的，程序每次都接受相同的输入，让模糊器（或者执行组件）自由地找到这一个值，然后进一步探索。发现崩溃后，可以用符号方式对随机性进行建模，如第V-D4节所述，并且可以相应地修补崩溃输入。


这些功能允许AFL快速发现应用程序中的唯一路径，在应用程序的给定隔离区中执行路径发现工作的主要任务。然而，模糊测试的局限性是众所周知的。

### B.模糊限制
因为模糊器随机改变输入，而遗传模糊器反过来改变输入，过去通过二进制生成唯一路径，它们能够快速发现处理“一般”输入的不同路径（即，具有许多输入的输入） 可以触发有意义的程序行为的不同值）。 然而，在应用程序中传递复杂检查的“特定”输入的生成（即，需要具有极少数特定值之一的输入的检查）对于模糊器来说是非常具有挑战性的。

清单2中的应用程序从用户读取值并将其与特定值进行比较。 如果提供了正确的值，应用程序将崩溃。 但是，由于模糊测试的性质，模糊器极不可能满足谓词。 对于非仪表化的模糊器（即，为输入选择随机值的模糊器），模糊器将发现该错误的可能性是232中的无穷小。对于仪表化的模糊器，将导致该二进制文件的控制流布局 在一条被发现的道路上。 如果没有对新路径进行优先排序的能力（因为没有），一个仪表化的模糊器将被简化为在现有路径上应用随机变化，这实质上与非仪器化案例相同，具有相同的极小机会。 成功。

### C.过渡到乡村执行
Driller旨在通过利用强制执行的优势，补充模糊测试的基本弱点，确定通过复杂检查所需的特定用户输入。当模糊测试分量经历了预定量（与输入长度成比例）的突变而没有识别出新的状态转换时，我们认为它“卡住”了。然后，Driller检索模糊器在当前隔间中认为“有趣”的输入，并在它们上调用concolic执行引擎。


如果两个条件之一成立，则模糊器将输入识别为有趣：
1）输入导致应用程序采用的路径是第一个触发某些状态转换的路径。
2）输入导致应用程序采用的路径是第一个放入唯一“循环桶”的路径。


这些条件将传递给concolic执行组件的输入数量保持在一个合理的数量，同时保留很高的传递输入的机会，这些输入可以突变执行以到达应用程序中的下一个隔离区。


## 5 COncolic Execution


当Driller确定模糊器无法找到其他状态转换时，会调用concoic执行引擎。 Driller使用concolic执行的见解如下：模糊器未能在程序中找到新状态转换的主要原因之一是模糊器无法生成特定输入以满足代码中的复杂检查。 concolic执行引擎用于利用符号求解器来改变现有的输入，这些输入到达但不能满足复杂的检查，以达到达到并满足此类检查的新输入。

当Driller调用concolic执行引擎时，它会传递由模糊测试引擎识别的所有“有趣”输入（如第IV-C节中所定义）。 象征性地跟踪每个输入以识别模糊引擎不能满足的状态转换。 

当识别出这样的转换时，concoic执行引擎产生输入，该输入将通过该状态转换驱动执行。
在concoic执行引擎完成处理提供的输入之后，其结果被反馈到模糊测试引擎的队列中，并且控制被传递回模糊引擎，以便它可以快速浏览新发现的应用程序的分区。


本节的其余部分将描述Driller实施的concolic执行以及我们为Driller问题域所做的具体调整。


### A.临时执行
我们利用angr [29]，一个最近开源的符号执行引擎，用于Driller的concolic执行引擎。该引擎基于Mayhem和S2E推广和改进的模型[8]，[10]。首先，引擎将二进制代码转换为Valgrind的VEX [24]中间表示，该表示被解释为确定程序代码对符号状态的影响。此符号状态使用符号变量来表示可能来自用户的输入或非常量的其他数据，例如来自环境的数据。符号变量是一个变量（例如X），它可以产生许多可能的具体解决方案（例如数字5）。其他值（例如程序中硬编码的常量）被建模为具体值。随着执行的进行，符号约束被添加到这些变量中。约束是对符号值的潜在解决方案的限制性陈述（例如，X <100）。具体的解决方案是满足这些约束的X的任何值。

分析引擎在整个执行过程中跟踪存储器中的所有具体和符号值以及寄存器（上述符号状态）。在引擎到达的程序中的任何点处，可以执行约束解析以确定满足对状态中的所有符号变量的约束的可能输入。当传递给应用程序的正常执行时，这样的输入将驱动应用程序到那一点。有条理执行的优点是它可以探索和查找约束求解器可以满足的任何路径的输入。这使得它可以用于识别复杂比较的解决方案（包括某些散列函数），模糊器不太可能暴力破解。


Driller的符号记忆模型可以存储具体和符号值。它使用基于索引的内存模型，其中读取地址可能是符号，但写入地址始终具体化。这种由Mayhem推广的方法是保持分析可行的一个重要优化：如果读取和写入地址都是符号，则使用相同符号索引重复读取和写入将导致符号约束的二次增加，或者取决于符号执行引擎的实现细节，存储的符号表达式的复杂性。因此，符号写地址始终具体化为单个有效解决方案。在某些条件下，如本领域文献所提出的，符号值被具体化为单一的潜在解决方案[8]。





