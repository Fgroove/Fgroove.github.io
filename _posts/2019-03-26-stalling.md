---
layout: post
title:  "Stalling"
date:   2019-03-26 08:55:01 +0800
categories: 基于动态的恶意软件分析
tag: 论文调研
---
* content
{:toc}


# CCS2011`Automated Detection and Mitigation of Execution-Stalling Malicious Code

## 摘要

恶意软件仍然是当今互联网上最重要的安全问题之一。

每当反恶意软件解决方案变得流行时，恶意软件作者通常会立即做出反应并修改其程序以逃避防御机制。

例如，最近，恶意软件作者越来越多地开始创建可以逃避动态分析的恶意代码。最近逃避动态分析系统的一种形式是停止代码。失败代码通常在任何恶意行为之前执行。攻击者的目标是延迟恶意活动的执行时间足够长，以便自动动态分析系统无法提取有趣的恶意行为。

研究人员Clemens Kolbitsch，Engin Kirda和Christopher Kruegel于2011年10月在芝加哥举行的ACM计算机和通信安全会议上发表了一篇著名的开创性科学论文，作者介绍了HASTEN，这是第一个检测和缓解恶意拖延代码的工具。并确保在分析样本分配的时间内向前进展。

本文的所有共同作者，Kolbitsch博士，Kirda博士和Kruegel博士都是Lastline的创始成员。在本白皮书中，我们给出了该科学工作的执行摘要，并使用了该论文的摘录。

Lastline构建了新颖且改进的工具，这些工具在概念上与HASTEN类似，但在实践中更有效和更有效。 请注意，与竞争对手相比，处理试图逃避检测的恶意软件样本是Lastline分析技术的重要主要特征之一。

## 介绍

恶意软件（恶意软件）是网络上许多安全问题背后的驱动力。 例如，世界上大部分的垃圾邮件是由僵尸网络发送的，特洛伊木马程序窃取了网上银行网站的帐户凭据，恶意软件程序参与了点击欺诈活动和分布式拒绝服务攻击。
恶意软件研究是一场军备竞赛。 随着新的反恶意软件解决方案的推出，攻击者正在更新其恶意代码以逃避分析和检测。 例如，当**基于签名**的反病毒扫描程序被广泛采用时，攻击者开始使用**代码混淆**和**加密**来阻止检测。 因此，研究人员和安全厂商转向专注于恶意软件的运行时（动态）行为的技术。
基于行为的恶意软件检测的重要推动因素是动态分析系统。 这些系统在受控环境中执行**捕获的恶意软件程序并记录其操作**（例如系统调用，API调用和网络流量）。 根据收集的信息，可以决定程序的恶意性质，优先考虑手动分析工作，并自动派生捕获恶意软件行为的模型。 然后可以部署这些模型以保护最终用户的机器。
随着动态分析系统变得越来越流行，恶意软件作者通过设计技术来响应，以确保他们的程序在这样的自动分析环境中执行时不会泄露任何恶意活动。 显然，当恶意软件在分析期间没有显示任何不需要的活动时，不能提取任何检测模型。 对于反恶意软件研究人员来说，这些逃避尝试在实践中构成了一个重大问题。

阻止动态分析的常用方法是识别执行样本的环境。为此，恶意软件程序使用检查（所谓的**红色药丸**）来确定它是在虚拟机还是系统仿真器（如Qemu）中执行。每当恶意软件程序能够检测到它在这样的环境中运行时，它就可以直接退出。
学术研究人员针对规避检查（红丸）做出了反应，提出了更加**透明**的分析环境。另一种学术方法侧重于检测虚拟平台中的程序执行与真实硬件之间的差异。当识别出这种差异时，可以删除负责差异的检查。最后，执行**多路径探索**的系统（例如Lastline的分析环境）可以检测并绕过防范恶意活动的检查。
在军备竞赛的下一步中，恶意软件作者已经开始在其恶意程序中引入**拖延代码**。此拖延代码在任何恶意行为之前执行 - 无论执行环境如何。这种规避代码的目的是延迟恶意活动的执行时间足够长，以便自动分析系统放弃样本，错误地假设程序无法运行，或者不执行任何感兴趣的操作。重要的是要注意，**拖延代码的问题会影响所有分析系统，甚至是那些完全透明的分析系统**。此外，停止代码不必执行任何检查。

随着代码停滞，攻击者利用自动恶意软件分析系统的两个常见属性：首先，**系统执行单个样本所花费的时间是有限的**。通常，自动恶意软件分析系统将在几分钟后终止样本分析。这是因为系统必须在可以从单个样本获得的信息与每天可以分析的样本总数之间进行权衡。其次，**恶意软件作者可以制作他们的代码，以便在分析环境中执行的时间比在实际的受害者主机上花费的时间长得多**。
因此，即使样本可能在分析环境中长时间（许多分钟）停止并且不执行任何恶意活动，受害主机上感知的延迟也只有几秒钟。这很重要，因为恶意软件作者认为受害者机器上的延误是有风险的。原因是**反病毒软件，留心的用户或系统重启更有可能检测到或终止恶意进程**。

在他们关于HASTEN的工作中，Kolbitsch博士，Kirda博士和Kruegel博士提出了第一种检测和规避恶意拖延代码的方法，并确保在分配样本时分配的时间内取得进展。 为此，他们引入了检测恶意软件样本何时在分析过程中没有取得足够进展的技术； 遇到这种情况时，系统会自动检查样本，以识别可能导致执行拖延的代码区域。 对于这些代码区域（仅限这些区域），禁用昂贵的日志记录。 当这还不够时，研究人员强迫执行采取跳过（退出）先前识别的停滞代码的路径。 在Lastline，我们开发了一种类似的方法来处理执行停止代码。

## 问题描述

我们将拖延代码区域定义为满足两个属性的指令序列：首先，**指令序列在分析环境中的运行速度比在实际（本机）主机上慢得多**。在这种情况下，“相当慢”意味着与沙箱导致正常，良性程序的平均减速相比，减速很大。慢操作的示例是调用系统调用（由于额外的日志记录开销）和模拟开销特别大的机器指令（例如，浮点操作或MMX代码）。
停止代码的第二个特性是它的**整个执行必须花费不可忽略的时间**。在这里，不可忽略的是必须与为程序的自动分析分配的总时间相关联。例如，对于动态分析系统，这可能是几分钟的量级。因此，我们希望停滞代码至少运行几秒钟。否则，分析结果不会受到显着影响。也就是说，当指令序列在几毫秒而不是几微秒内完成时，我们不认为这是停滞代码。
显然，攻击者可以创建拖延代码，以与在分析环境中相同的方式停止在真实主机上的执行。例如，攻击者可以使用睡眠调用，或者创建大量活动来延迟执行。然而，在实践中，可以容易地跳过使用类似睡眠的功能的执行延迟，并且延迟执行（例如，通过提高活动量）增加了在受害主机上被检测和终止的机会。

直觉上，我们的定义意味着停止代码包含“慢”操作（以满足第一个属性），并且这些操作重复多次（以满足第二个属性）。 因此，攻击者通常将停滞代码实现为**包含慢速操作的循环**（我们有时会将停滞代码称为此白皮书中的**停顿/拖延循环**）。

## 系统概述

我们Lastline的系统的目标是**检测停滞循环**并减轻它们对分析沙箱产生的分析结果的影响。特别是，我们的系统必须**确保分析在分配的分析时间范围内取得足够的进展**，以便我们能够尽可能多地暴露恶意活动。为此，我们的系统就像HASTEN一样，可以在三种模式下运行：监控，被动和主动模式。
**监控模式**。启动恶意软件样本分析后，系统将以监控模式运行。在此模式下，系统对正在分析的过程的所有线程执行**轻量级**观察。目标是测量每个线程的进度，并识别执行可能已进入停滞区域的实例。
**被动模式**。当监视模式检测到进度不足时，这通常是由于执行缓慢的操作将成功，并且恶意软件将终止而不会泄露任何其他恶意行为。
为了克服这个问题，我们的方法如下：在退出白名单代码区域之前，我们首先分析该区域代码所写的所有变量（内存位置）作为计算的一部分（逻辑和算术指令）。然后用特殊标签（污点）标记这些存储位置，表明它们的真实值是未知的。只要机器指令使用受污染的值作为源操作数，目标也会受到污染。为此，我们利用了这一事实，即我们已经在Lastline的**基于云的仿真器分析平台**上实现了原型解决方案，该平台已经支持**数据流（污点）跟踪**。
只要在**比较操作**或**间接存储器访问**中使用受污染的变量（使用此变量作为地址计算的一部分），系统就会暂时停止恶意软件进程的执行。然后，它提取一个以比较指令结束的**后向切片**，并在执行时计算该变量的正确值。提取切片后，它将在本机上执行。结果，与在真实受害者主机上执行相比，该计算不会产生任何开销。

## 结论

随着新的恶意软件分析解决方案的推出，攻击者通过调整恶意代码来逃避检测和分析。 最近一种用于动态分析系统的逃避代码形式是停滞代码。 

在本白皮书中，我们提出了第一种**学术方法HASTEN**，用于检测和缓解恶意拖延代码，并确保在分析样本时分配的时间内取得进展。 

我们在Lastline中**重新实现了HASTEN**，我们的结果表明该系统在实践中运行良好，并且能够揭示真实恶意软件样本中的其他行为，这些样本包含市场上竞争产品不可见的停滞代码。