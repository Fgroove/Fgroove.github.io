---
layout: post
title:  Tutorial
date:   2019-04-22 10:55:01 +0800
categories: 基于动态的恶意软件分析
tag: 论文调研
---
* content
{:toc}


# Tutorial: An Overview of Malware Detection and Evasion Techniques

---

## 摘要

本教程介绍各种恶意软件检测工具，并示例说明它们的用法。 我们演示了如何使用静态提取的语法签名来快速检测恶意软件的简单变体。 由于这些签名很容易被混淆，我们还提供动态提取的行为签名，这些签名是通过在称为沙箱的隔离环境中运行恶意软件而获得的。 但是，某些恶意软件可以使用沙箱检测来检测它们是否在这样的环境中运行，从而避免表现出恶意行为。 为了应对沙盒检测，我们提出了可以探索二进制文件的几个路径的concolic执行。 我们通过展示如何使用不透明谓词和JIT来阻止符号执行。

## 1 Introduction

**Context.**

**Malware signatures.**

**Static analysis.** 

**Dynamic analysis.**

**Concolic analysis.**

## 4 Concolic Analysis: Symbolic Execution

混合分析不执行二进制文件，而是模拟它，目的是尽可能多地覆盖二进制文件的执行路径。这增加了检测由于沙箱逃逸技术而无法在沙箱中执行的恶意行为的可能性。

在具体执行中，为变量分配具体值，只要在执行期间达到某些赋值语句，就会重新评估这些值。在符号执行中，变量是符号的，即被赋予一组表示一组可能的具体值的约束。

实际上，随着程序执行的进行，符号变量会累积对具体变量可能值的约束，而具体变量只保留最后一个实际赋值。因此，混合执行不像符号执行那样扩展。

在符号执行中，条件语句不仅与具体执行一样被评估为真或假，而是被评估为可满足或不可满足。这意味着，对于给定条件语句上的给定符号变量，如果可以同时满足条件语句及其否定，则执行将采用两个路径，而在具体执行中，将仅采用其中一个。

因此，虽然具体执行一次只能遍历一个执行跟踪，但符号执行可以同时遍历多个执行跟踪。因此，concolic execution旨在将具体执行的效率和可伸缩性与符号执行的高代码覆盖相结合。

### 4.1 Principle

### 4.2 Tool: angr

angr是一个实现二进制文件执行的工具，用Python编写并由不同的模块组成。

* CLE：代表“CLE Loads Everything”，负责加载二进制文件和库。

 -  Archinfo：包含特定体系结构的信息。
 -  PyVEX：用于处理VEX的Python模块，VEX是一个中间表示，使angr能够在不同的体系结构上工作。
 -  Claripy：与约束求解器接口的模块。

通过使用CLE模块加载二进制文件开始执行。 为此，CLE需要目标体系结构的信息，该信息由Archinfo提供。

加载二进制文件后，angr符号执行引擎协调符号执行。 angr分析的分析单元是基本块，定义为没有分支（例如跳转或调用）的连续代码序列，并且对于每个基本块，angr创建新状态。 状态包含程序的内存，寄存器，文件系统以及任何其他所谓的“实时数据”。

angr的执行逐步演变。 每个步骤将当前活动状态转换为其后继状态。 只要某些指令取决于符号变量（例如，存储器地址），就可以解决从过去的基本块/状态累积的约束。 如果当前状态以条件跳转结束，则angr根据当前约束评估条件并按如下方式进行。
 - 如果条件及其否定都是可满足的，则angr创建两个新的后继状态，用于两个可能状态中的每一个。
 - 如果只有一个条件及其否定是可满足的，则angr只创建一个新的后继状态。
 - 如果条件性和否定性都不可满足，则angr将状态标记为已退出并终止其执行。

Claripy接口的SMT求解器解决了约束问题。 目前，使用的默认SMT求解器是Microsoft的Z3，但是其他人可以通过编写适当的Claripy后端插入到angr中。

上述过程能够模拟裸机环境，包括底层操作系统提供的抽象，例如文件，网络，进程等。 为了实现这些抽象，angr包含一个名为SimOS的模块，它在分析过程中提供所有必需的OS对象。

最后，为了让angr能够使用多种体系结构，而不是对CLE收取的指令进行复杂的分析，这些指令首先在分析完成之前被提升到VEX中间表示。 可以将多个架构提升到VEX，而不会损失整体分析。

为了说明混合分析的好处，我们使用图8中的代码示例。使用angr运行完全自动分析，可以验证angr达到3个最终状态（即退化状态），对应于执行的叶子 树如图10所示。

图12显示了执行分析所需的命令。 可以检查对于三个退出状态中的每一个，分析到达原始代码的不同行（对应于不同的打印消息）。

对于给定状态，stdin可以通过posix.dump(0)访问，而stdout可以通过posix.dump(1)访问。 因此，如果x = 4，则可以直接验证执行是否成功。

### 4.3 Limitations: Symbolic Explosion

探索给定二进制文件的所有可能路径的能力是concolic执行的核心优势之一。 但是，恶意软件作者可以利用这一点来生成一个二进制文件执行具有大量可能路径的二进制文件。 例如，根据符号执行未被视为具体的值的n个条件跳转序列启动二进制文件可能会创建&2^n&个跟踪。 恶意软件作者可以使用此技术尝试填充运行符号执行的计算机的内存。 缓解该技术的一种方法是不用广度优先搜索（BFS）来命令探索可达状态。

符号执行的另一个弱点是约束求解器。实际上，一些恶意软件包括通常用于阻碍静态分析的不透明谓词。一个简单的例子是编写一个复杂的条件跳转，其条件总是求值为true，因此在运行时只采用条件跳转的一个分支，但静态分析需要花费很多精力来断定谓词总是为真。在符号执行的上下文中，这样的谓词可能变成涉及几个符号变量的非常复杂的表达式。这些谓词将由约束求解器进行分析，迫使求解器使用大量资源（时间和内存）来尝试解决约束。如果约束求解器耗尽资源，则执行必须分析两个路径，并且可以在从未在运行时选择的路径中插入复杂的死代码（可能包括更多不透明的谓词）以阻碍分析。

最后，符号执行还与即时（JIT）代码进行斗争，即在执行它们之前将下一条指令写入内存中的代码。如果某些书面指令在编写时是符号的，则执行现在面临着执行符号指令的问题。一个昂贵的解决方案是列出满足符号指令约束的所有指令并尝试每个指令。否则，此时可以停止符号执行或者错过某些分支。只要跳转的地址是符号的，就会遇到类似的问题。

对于我们的运行示例，我们使用Tigress来生成图6中代码的模糊版本。图13中显示的命令产生了一个对符号执行进行模糊处理的a.out可执行文件。尝试使用angr分析可执行文件时，该工具将执行而不会终止。

