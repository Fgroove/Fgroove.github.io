---
layout: post
title:  "X-Force"
date:   2019-05-14 9:55:01 +0800
categories: 例会
tag: meeting
---
* content
{:toc}


# X-Force

---

## Summary



## 摘要

本文介绍了一种新颖的二进制分析引擎X-Force。

X-Force可以强制执行二进制文件，无需输入或适当的环境。

它还通过系统地分析一小组条件控制转移指令的分支结果来探索二进制内部的不同执行路径。

 X-Force具有无崩溃执行模型，可以检测异常并从异常中恢复。

特别是，它可以通过按需分配内存并将有问题的指针设置为分配的内存来修复无效的内存访问。

我们已将X-Force应用于三个安全应用程序。第一个是构造控制流图和调用剥离的二进制图。第二种是暴露恶意软件的隐藏行为，包括打包和混淆的APT恶意软件。 X-Force能够揭示人工检查遗漏的隐藏的恶意行为。在第三个应用中，X-Force显着改善了剥离二进制的动态类型重建中的分析覆盖。

## Intro

二进制分析有许多安全应用程序。例如，给定一个未知的，可能是恶意可执行的二进制分析，有助于构建其人类可观的表示，如控制流图（CFG）和调用图（CG），安全分析师可以使用它来研究其行为。二进制分析还有助于识别和修补COTS二进制文件中的安全漏洞。有价值的信息可以通过二进制分析从可执行文件中进行反向工程。这些信息包括网络协议，输入格式，变量类型和数据结构定义。它们可以支持网络嗅探，漏洞利用生成，VM内省和取证分析。

现有的二元分析可大致分为静态，动态和符号（concolic）分析。静态分析直接分析可执行文件而不执行它;动态分析通过执行二进制获取分析结果;符号（concolic）分析能够生成输入以探索二元的不同路径。这些不同类型的分析具有各自的优势和局限性。**静态分析难以处理打包和混淆的二进制文件。**已知**内存消歧**和**间接跳跃/调用目标**分析对于静态分析非常具有挑战性。

动态二进制分析基于在一组输入上执行二进制文件。它广泛用于分析恶意软件。然而，动态分析本质上是不完整的。分析结果的质量很大程度上取决于**测试输入的覆盖范围**。此外，现代恶意软件变得非常复杂，为二进制分析带来了许多新的挑战：（1）对于零日二进制恶意软件，我们通常对它没有任何了解，尤其是其输入的本质，使传统的基于执行的分析变得困难; （2）恶意软件二进制文件越来越多地配备了反分析逻辑，因此即使给定有效输入也可能拒绝运行; （3）恶意软件的错误可能包含多阶段，条件保护和环境特定的恶意有效载荷，这使得很难揭示所有有效载荷，即使有人设法执行它们也是如此。

近年来，符号分析取得了很大进展。一些处理二进制程序并且可以探索二进制中的各种路径。但是，将它们缩放到复杂的真实世界二进制文件时存在困难，因为它们通过将单个指令建模为符号约束并使用SMT / SAT求解器来解决生成的约束来进行操作。尽管最近有令人印象深刻的进展，但SMT / SAT仍然很昂贵，虽然可以同时执行符号和混合执行，以便在符号分析遇到困难时具体执行可能有所帮助，但用户需要提供具体的输入，称为种子输入，**种子输入的质量**对于执行路径至关重要可以探索。由于没有或很少了解恶意软件输入，因此难以创建此类种子输入。此外，许多现有技术无法处理混淆或自修改二进制文件。

在本文中，我们提出了一种名为X-Force的新型实用执行引擎。 X-Force背后的核心启用技术是**强制执行**，顾名思义，它强制任意二进制文件在不同的路径上执行，无需任何输入或环境设置。更具体地说，X-Force通过动态二进制检测来监视二进制文件的执行，系统地强制可能影响执行路径的一小组指令（例如，谓词和跳转表访问）具有特定值，而不管它们是什么输入值，并在需要输入时提供随机值。因此，可以系统地探索二进制的具体程序状态。例如，通过设置自我保护检查的分支结果，可以强制打包/混淆的恶意软件解压缩/自我混淆，这会在调试器或虚拟机存在时终止执行。 X-Force能够通过执行按需内存分配来容忍无效的内存访问。此外，通过探索二进制的可达状态，X-Force能够探索二进制行为的不同方面或阶段。例如，我们可以暴露恶意软件的数据泄漏操作，而不会使真正的数据成为目标。

与手动检查和静态分析相比，X-Force更准确，因为静态分析的许多困难，例如处理间接跳转/调用和混淆/打包代码，可以通过X-Force的具体执行得到显着减轻。与符号/共同分析相比，X-Force在实用性和可扩展性方面更好，略微牺牲精度。请注意，X-Force可以探索不可行的路径，因为它会**强制谓词结果**;而符号分析则试图通过**约束求解**来尊重路径的可行性。 X-Force的本质将在后面的第6节中讨论。此外，X-Force中的执行都是具体的。在不需要建模和解决约束的情况下，X-Force更有可能扩展到大型程序和长时间执行。 X-Force的具体执行使其适用于分析打包和混淆的二进制文件。它还可以轻松地将现有的动态分析移植到X-Force，以利用大量的执行，从而减少动态分析的不完整性。

我们的主要贡献总结如下：

* 我们提出X-Force，这个系统可以强制执行二进制文件，无需输入或任何环境设置。
* 我们开发了一种无崩溃的执行模型，可以正确地检测和恢复异常。 我们还开发了各种执行路径探索算法。
* 我们已经解决了使技术在真实世界二进制文件上工作的技术挑战，包括打包和混淆的恶意软件二进制文件。
* 我们开发了三种X-Force应用程序。 第一个是构建剥离双子的CFG和CG，具有高质量的间接跳跃和呼叫目标识别; 二是研究高级恶意软件的隐藏行为; 第三个是在反向工程变量类型和可执行文件的数据结构定义中应用X-Force。 我们的研究结果表明，X-Force大大提升了先进水平。

## Motivation

```c
void main() {
  int x=inoutInt(...);
  if (C(x))
    p=(DNSentry*)malloc(...);
  if (x & CODE_RED) {
    genName(x,p);
    table_put(x,p);
  }
  ...
  table_put(...,o); /*o is of type T*/
  ...
  s=table_get(y); /*y==x through execution*/
  if (s)
    /* redirection dor the domain specified by s*/
}
```



考虑图1中的片段。它显示了一个隐藏的恶意有效负载，它劫持了特定域名（第14行）的名称解析，该域根据当前日期（函数genName（））而变化。特别是，它在第2行接收到一些整数输入。如果输入满足第3行的条件C，则将分配DNSentry对象。在第5-8行中，如果输入设置了CODE RED位，则通过调用genName（）填充对象，并将输入和生成的名称作为（键，值）对存储到哈希表中。在第12-14行中，检索该对并用于指导域名重定向。注意，哈希表用作各种类型对象的通用存储。在第10行中，还将无关对象o插入表中。
这个例子说明了静态和符号/复杂分析所面临的一些挑战。在静态分析中，很难确定在第12行收到的对象是第7行插入的对象，因为抽象域必须精确地建模哈希表put / get操作的行为和条件y == x，这需要上下文敏感和路径敏感的分析，并消除表get（）和表put（）中的存储桶[i]和bucket [i + 4]的歧义。许多静态分析技术所做的近似通常决定了第12行的对象可能是放在第7行或第10行的对象。仅在二进制级别执行，这样的分析实际上比这里描述的更具挑战性。在符号/符号分析中，可以将第2行的输入建模为符号变量，使得通过求解对应于路径条件的符号约束，可以达到隐藏的有效载荷。但是，如果文件不可用，则在第21行读取的字典将难以处理。如果文件具有非常重要的格式和大小，则将文件编辑为符号通常会导致可伸缩性问题，因为生成的符号约束通常很复杂，并且用于获取语法正确输入的搜索空间可能非常大。