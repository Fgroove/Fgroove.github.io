---
layout: post
title:  "X-Force"
date:   2019-05-14 9:55:01 +0800
categories: 例会
tag: meeting
---
* content
{:toc}


# X-Force

---

[X-Force: Force-Executing Binary Programs for Security Applications](https://www.usenix.org/node/184514)

## Summary

强制执行路径：随机输入/按需分配内存/异常恢复机制等目的都是保证路径可以强制执行，暴露恶意行为。

线性集追踪语义：保证指针更新的一致性，指针变量一般只有加减操作，更简单。

* L-INIT:具有地址值的所有全局变量的SM映射被设置为它自己的地址，这意味着变量最初仅与其自身线性相关



内存错误检测和恢复规则：

路径探索：

## 摘要

本文介绍了一种新颖的二进制分析引擎X-Force。

X-Force可以强制执行二进制文件，无需输入或适当的环境。

它还通过系统地分析一小组条件控制转移指令的分支结果来探索二进制内部的不同执行路径。

 X-Force具有无崩溃执行模型，可以检测异常并从异常中恢复。

特别是，它可以通过按需分配内存并将有问题的指针设置为分配的内存来修复无效的内存访问。

我们已将X-Force应用于三个安全应用程序。第一个是构造控制流图和调用剥离的二进制图。第二种是暴露恶意软件的隐藏行为，包括打包和混淆的APT恶意软件。 X-Force能够揭示人工检查遗漏的隐藏的恶意行为。在第三个应用中，X-Force显着改善了剥离二进制的动态类型重建中的分析覆盖。

## Intro

二进制分析有许多安全应用程序。例如，给定一个未知的，可能是恶意可执行的二进制分析，有助于构建其人类可观的表示，如控制流图（CFG）和调用图（CG），安全分析师可以使用它来研究其行为。二进制分析还有助于识别和修补COTS二进制文件中的安全漏洞。有价值的信息可以通过二进制分析从可执行文件中进行反向工程。这些信息包括网络协议，输入格式，变量类型和数据结构定义。它们可以支持网络嗅探，漏洞利用生成，VM内省和取证分析。

现有的二元分析可大致分为静态，动态和符号（concolic）分析。静态分析直接分析可执行文件而不执行它;动态分析通过执行二进制获取分析结果;符号（concolic）分析能够生成输入以探索二元的不同路径。这些不同类型的分析具有各自的优势和局限性。**静态分析难以处理打包和混淆的二进制文件。**已知**内存消歧**和**间接跳跃/调用目标**分析对于静态分析非常具有挑战性。

动态二进制分析基于在一组输入上执行二进制文件。它广泛用于分析恶意软件。然而，动态分析本质上是不完整的。分析结果的质量很大程度上取决于**测试输入的覆盖范围**。此外，现代恶意软件变得非常复杂，为二进制分析带来了许多新的挑战：（1）对于零日二进制恶意软件，我们通常对它没有任何了解，尤其是其输入的本质，使传统的基于执行的分析变得困难; （2）恶意软件二进制文件越来越多地配备了反分析逻辑，因此即使给定有效输入也可能拒绝运行; （3）恶意软件的错误可能包含多阶段，条件保护和环境特定的恶意有效载荷，这使得很难揭示所有有效载荷，即使有人设法执行它们也是如此。

近年来，符号分析取得了很大进展。一些处理二进制程序并且可以探索二进制中的各种路径。但是，将它们缩放到复杂的真实世界二进制文件时存在困难，因为它们通过将单个指令建模为符号约束并使用SMT / SAT求解器来解决生成的约束来进行操作。尽管最近有令人印象深刻的进展，但SMT / SAT仍然很昂贵，虽然可以同时执行符号和混合执行，以便在符号分析遇到困难时具体执行可能有所帮助，但用户需要提供具体的输入，称为种子输入，**种子输入的质量**对于执行路径至关重要可以探索。由于没有或很少了解恶意软件输入，因此难以创建此类种子输入。此外，许多现有技术无法处理混淆或自修改二进制文件。

在本文中，我们提出了一种名为X-Force的新型实用执行引擎。 X-Force背后的核心启用技术是**强制执行**，顾名思义，它强制任意二进制文件在不同的路径上执行，无需任何输入或环境设置。更具体地说，X-Force通过动态二进制检测来监视二进制文件的执行，系统地强制可能影响执行路径的一小组指令（例如，谓词和跳转表访问）具有特定值，而不管它们是什么输入值，并在需要输入时提供随机值。因此，可以系统地探索二进制的具体程序状态。例如，通过设置自我保护检查的分支结果，可以强制打包/混淆的恶意软件解压缩/自我混淆，这会在调试器或虚拟机存在时终止执行。 X-Force能够通过执行按需内存分配来容忍无效的内存访问。此外，通过探索二进制的可达状态，X-Force能够探索二进制行为的不同方面或阶段。例如，我们可以暴露恶意软件的数据泄漏操作，而不会使真正的数据成为目标。

与手动检查和静态分析相比，X-Force更准确，因为静态分析的许多困难，例如处理间接跳转/调用和混淆/打包代码，可以通过X-Force的具体执行得到显着减轻。与符号/共同分析相比，X-Force在实用性和可扩展性方面更好，略微牺牲精度。请注意，X-Force可以探索不可行的路径，因为它会**强制谓词结果**;而符号分析则试图通过**约束求解**来尊重路径的可行性。 X-Force的本质将在后面的第6节中讨论。此外，X-Force中的执行都是具体的。在不需要建模和解决约束的情况下，X-Force更有可能扩展到大型程序和长时间执行。 X-Force的具体执行使其适用于分析打包和混淆的二进制文件。它还可以轻松地将现有的动态分析移植到X-Force，以利用大量的执行，从而减少动态分析的不完整性。

我们的主要贡献总结如下：

* 我们提出X-Force，这个系统可以强制执行二进制文件，无需输入或任何环境设置。
* 我们开发了一种无崩溃的执行模型，可以正确地检测和恢复异常。 我们还开发了各种执行路径探索算法。
* 我们已经解决了使技术在真实世界二进制文件上工作的技术挑战，包括打包和混淆的恶意软件二进制文件。
* 我们开发了三种X-Force应用程序。 第一个是构建剥离双子的CFG和CG，具有高质量的间接跳跃和呼叫目标识别; 二是研究高级恶意软件的隐藏行为; 第三个是在反向工程变量类型和可执行文件的数据结构定义中应用X-Force。 我们的研究结果表明，X-Force大大提升了先进水平。

## Motivation

```c
void main() {
  int x=inoutInt(...);
  if (C(x))
    p=(DNSentry*)malloc(...);
  if (x & CODE_RED) {
    genName(x,p);
    table_put(x,p);
  }
  ...
  table_put(...,o); /*o is of type T*/
  ...
  s=table_get(y); /*y==x through execution*/
  if (s)
    /* redirection for the domain specified by s*/
}




void genName(int x, DNSentry *q) {
  inputDictoinary();
  *(q->name)=...Lookup(x,date())...;
}

void * table_get(int key) {
  .../* i is derived from key*/
  if (key==bucket[i])
    return bucket[i+4];
}
void table_put(int key, void* value) {
  .../* i is derived from key*/
  bucket[i]=key;
  bucket[i+4]=value;
}
```



考虑图1中的片段。它显示了一个隐藏的恶意有效负载，它劫持了特定域名（第14行）的名称解析，该域根据当前日期（函数`genName()`）而变化。特别是，它在第2行接收到一些整数输入。如果输入满足第3行的条件C，则将分配DNSentry对象。在第5-8行中，如果输入设置了`CODE_RED`位，则通过调用`genName()`填充对象，并将输入和生成的名称作为（键，值）对存储到哈希表中。在第12-14行中，检索该对并用于指导域名重定向。注意，哈希表用作各种类型对象的通用存储。在第10行中，还将**无关对象o**插入表中。

这个例子说明了静态和符号/复杂分析所面临的一些挑战。**在静态分析中，很难确定在第12行收到的对象是第7行插入的对象**，因为抽象域必须精确地建模哈希表put/get操作的行为和条件y == x，这需要上下文敏感和路径敏感的分析，并消除`table_get()`和`table_put()`中的存储`bucket[i]`和`bucket[i+4]`的歧义。许多静态分析技术所做的近似通常决定了第12行的对象可能是放在第7行或第10行的对象。

仅在二进制级别执行，这样的分析实际上比这里描述的更具挑战性。在符号/符号分析中，可以将第2行的输入建模为符号变量，使得通过求解对应于路径条件的符号约束，可以达到隐藏的有效载荷。但是，如果文件不可用，则在第21行读取的字典将难以处理。如果文件具有非常重要的格式和大小，则将文件编辑为符号通常会导致可伸缩性问题，因为生成的符号约束通常很复杂，并且用于获取语法正确输入的搜索空间可能非常大。

在X-Force中，首先通过提供**随机输入**来执行二进制文件。请注意，X-Force不需要事先知道输入格式，因为它的异常恢复机制可以防止任何崩溃/异常。换句话说，随机输入值的提供仅仅是为了允许执行继续进行，而不是沿着不同的路径驱动执行。在第一次正常运行中，假设第3,5和13行的条件的假分支被采用，产生无趣的执行。然后，X-Force将尝试通过执行系统搜索来强制设置少量（例如，1或2）谓词的分支结果。假设第5行的分支结果被强制设置为“true”。恶意有效载荷将被强制激活。请注意，指针p在第6行具有空值，这通常会使第22行的执行崩溃。X-Force通过在第22行之前按需定位内存来容忍此类无效访问。此外，即使第21行字典文件不存在，X-Force将通过提供随机输入值来强制它通过。因此，一些**随机整数和域**被插入表（第7行）并稍后检索（第12行）。最终，**随机域名在第14行被重定向**，从而暴露了DNS劫持操作。我们认为，只要隐藏的劫持逻辑被暴露，域名本身并不重要。

## 3.设计

### 3.1 强制执行语义

本节介绍单个强制执行如何进行的基础知识。 目标是进行不会崩溃的执行。 为了便于阅读，我们重点介绍如何检测和恢复此子句中的内存错误，然后逐步介绍强制执行的其他方面，如路径探索和处理库和后续部分中的线程。

**语言：**由于x86指令集的复杂性，我们引入了一种简单的低级语言，它可以模拟x86二进制可执行文件以方便讨论。我们只模拟一个足以说明关键思想的子集。图2显示了语法。

内存读写由`R(ra)`和`W(ra，rv)`建模，ra保持地址，rv为值。由于它是一种低级语言，我们不会模拟条件或循环语句，而是保护跳跃; `malloc()`和`free()`表示堆分配和释放。函数调用和返回由`call()`和`ret`建模。在我们的语言中，堆栈/堆内存地址被建模为一个整数范围，一个特殊值0表示空指针值。程序计数器（或指令地址）由PC集明确建模。观察每条指令都用PC标记，表示其指令地址。直接跳转/调用使用PC值进行参数化，而间接跳转/调用则使用寄存器进行参数化。

---

*自定义语法，模拟x86; 下面是线性集追踪语义*

---

在X-Force中，我们通过按需分配内存来确保执行不可崩溃。但是，当我们用分配的内存替换指向无效地址a的指针时，我们需要更新具有相同地址值的所有其他指针变量或表示与地址的偏移量的值。我们通过**线性集跟踪语义**来实现这一点，**线性集跟踪语义也是强制执行的基本语义**。其目标是识别变量集（即二进制级别的存储器位置和寄存器），其值具有线性相关性。***在本文中，我们说如果一个变量的值通过加减一个值来计算另一个变量的值，则两个变量是线性相关的***。请注意，它比传统的线性相关定义更简单，没有乘除。然而，在这项工作中足够了，因为线性集跟踪的目标是识别相关指针变量，这些变量由地址偏移引起，这些地址偏移仅是加法和减法。

语义如表1所示。相应的定义如图3所示。特别是，线性集`LSet`表示一组地址，使得存储在这些地址中的值是线性相关的。映射SR将**寄存器**映射到LSet的引用。直观地，人们可以解释它将寄存器映射到指向一组地址的指针，使得存储在寄存器中的值和那些地址是线性相关的。两个寄存器映射到相同的引用（LSet）意味着两个寄存器的值也是线性相关的。类似地，映射SM将**地址**映射到LSet的引用，使得地址中的值和LSet中的所有地址线性相关。**线性集跟踪的本质是维护已访问的所有寄存器和地址的SR和SM映射，以便在任何执行点，我们可以查询任何给定变量的线性相关变量集。**

在执行之前，具有地址值的所有全局变量的SM映射被设置为它自己的地址，这意味着变量最初仅与其自身线性相关（规则`L-INIT`）。函数`isAddr(v)`确定值v是否可以是地址。 X-Force监控所有内存分配和映像加载过程。因此，给定一个值，如果X-Force落入静态，堆或堆栈内存区域，则将其视为指针。请注意，我们不需要确定该值确实是一个地址。**过近似**仅引起一些额外的线性集跟踪。对于存储器读操作，如果SM集存在，则目标寄存器的SR映射指向地址寄存器中值的SM集，这意味着该值是地址，否则设置为`nil``（规则L-READ` ）。请注意，在规则中我们使用“r”表示r的符号名称，ra表示存储在ra中的值。 $$SR("r")→SM(r_a)$$表示我们将`SR("r")`设置为指向`SM(ra)`集。对于**存储器写入**，我们首先从其线性集中消除目标地址。然后，地址被添加到值寄存器的线性集合，因为地址基本上表示新的线性相关变量。最后，更新地址的SM映射（规则`L-WRITE`）。请注意，操作“=”表示设置更新，这与“→”不同，表示设置映射更新。对于简单的地址分配，SR集设置为指向空线性集，这与`nil`值（规则`L-ADDR`）不同。空集本质上是一个LSet对象，可以由多个寄存器指向它们以表示它们的线性关系。零值不能用于此目的。对于线性运算符，目标寄存器的SR映射设置为指向保存地址值的寄存器的SR映射（规则`L-LINEAR`）。直觉上，这是因为我们只对地址值之间的线性相关感兴趣（出于内存错误恢复的目的）。对于堆是释放，我们必须从其线性集（规则`L-FREE`）中删除每个解除分配的地址。

---

*内存错误检测和恢复规则—按需分配*

---

表2列出了一组内存错误检测和恢复规则。相关定义如图3所示。引入辅助映射`accessible()`来表示地址是否已分配且因此可访问。 `M-ALLOC`和`M-FREE`规则是标准的。在读取或写入不可访问的地址时，X-Force调用函数`recover()`，寄存器保持无效地址以执行恢复。在函数中，我们首先获取线性集中所有变量的值，并确定最小值和最大值（第1-6行）。请注意，值可能不同（通过地址偏移操作）。然后，我们根据值的范围和预定义的默认内存块大小按需分配一块内存。然后在第9-12行中，线性集中的变量根据它们在块中的偏移量而更新。我们想指出按需分配可能没有分配足够的空间。但是，当发生越界访问时，将检测到这种不足，并进一步按需重新分配。我们还想指出，正确开发的程序在读取之前首先会写入地址。因此，按需分配通常由第一次写入无效缓冲区触发，以便可以正确写入并稍后读取该值。换句话说，我们不需要在按需分配的缓冲区中恢复值。

在我们的实际实现中，我们还更新所有线性相关的寄存器，这可以通过识别指向同一组的寄存器来确定。此外，规则仅描述了我们如何确保堆内存安全，而X-Force保护关键堆栈地址，如返回地址和参数，我们将在后面讨论。

**示例：**图4显示了具有线性集跟踪和内存安全语义的示例执行的一部分。该计划来自动机示例（图1）。在执行中，采用第3行的else分支，但强制执行第5行的真分支。因此，指针p在传递给函数`genName()`时具有空值，这将在第22行引起异常。在图4中，我们关注第6,22和7行的执行。第二节列显示二进制代码（以我们的简化语言）。第三列显示了相应的线性集计算和内存异常检测和恢复。最初，根据规则`L-INIT`，`SM(＆p = 0x8004c0)`被设置为指向集合`{0x8004c0}`。在二进制代码行2处，`SR(eax)`被设置为指向`SM(＆p)`的集合。在第3行，由于该值被进一步复制到堆栈地址`0xce0080`，`eax`，`＆p`和堆栈地址都指向包含`＆p`和堆栈地址的相同线性集。直观地，这些是线性相关的三个变量。在第9行和第10行，`edi`进一步指向相同的线性集。在第12行，当程序试图访问由edi = 4表示的地址时，存储器安全组件检测到异常并执行按需分配。根据线性集，`＆p`和堆栈地址`0xce0080`设置为新分配的地址`0xd34780`，而`edi`根据其偏移量更新为`0xd34784`。虽然未在表中显示，但程序进一步初始化新分配的数据结构。结果，当指针p稍后传递给`table_put()`时，它指向有效的数据结构。

在项目的早期阶段，我们尝试了一种更为简单的策略，即在**发现异常时终止强制执行**。但是，我们观察到，由于我们不提供任何实际输入，因此异常非常常见。此外，**简单地跳过导致异常的指令也不起作用**，因为这会对程序状态的破坏产生连锁效应。最后，提出的不会崩溃的执行模型被证明是最有效的。

X-Force还可以通过跳过导致异常的指令，自动从其他异常中恢复，例如除零。细节被省略。

## 3.2 X-Force路径探索





