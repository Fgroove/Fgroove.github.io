---
layout: post
title:   "Nitro"
date:   2019-07-02 08:55:01 +0800
categories: "research proposal"
tag: "技术思路"


---

[TOC]





# Nitro: Hardware-Based System Call Tracing for Virtual Machines
VMI是在hypervisor层面监控和分析虚拟机状态的方法。因此Nitro对客户机OS不可见。

* Guest OS Portability.可移植性，Nitro不依赖GuestOS，因此无需改动就可在客户机间移植。
* Evasion-Resistance.部署好系统之后，攻击者无法逃逸。

为了翻译虚拟机里面底层的二进制状态信息，hypervisor必须借助硬件结构或者GuestOS信息来弥补语义鸿沟。

## 实现

KVM分为两部分：

* 基于QEMU构建的用户应用程序:提供QEMU监视器，它是管理程序的类似shell的接口。 它提供对VM的一般控制。所有Nitro命令都通过此监视器输入。
* 一组Linux内核模块：这些命令通过I / O控制接口发送到KVM的内核模块部分。最后，通过使用proc文件系统实现输出。 

在某些情况下，硬件制造商提供的虚拟化扩展支持捕获您感兴趣的特定事件，这使得工作变得简单。但是，**通常情况下，特别是对于安全机制，硬件扩展不支持捕获所需的事件**。在这些情况下，我们必须**间接地向虚拟机管理程序引入陷阱**。找到这些用于捕获所需事件的间接方法通常是一项挑战。

事实证明，在流行的Intel IA-32（即x86）和Intel 64（以前的EM64T）架构上不支持在系统调用事件时捕获到管理程序。在这种情况下，我们必须找到一种**间接导致陷阱**的方法，如上所述。我们通过**强制系统中断**（例如，页面错误，一般保护错误等）来实现此目的，英特尔虚拟化扩展（VT-x）支持这些终端。因此，我们已经有效地创建了一种**捕获系统调用**的机制，即使硬件扩展本身不支持这一点。由此产生的控制流程如图2所示。由于三个系统调用机制的性质完全不同，因此必须为每个系统调用机制设计一个独特的陷阱机制。下面描述这些捕获机制及其实现。

系统调用也可以使用`SYSCALL`指令及其模拟对应`SYSRET`来实现。这两者都依赖于一组MSR，即STAR MSR，CSTAR MSR和LSTAR MSR。究竟使用哪些寄存器取决于guest虚拟机操作系统是以传统模式，长模式还是兼容模式运行。另外，通过在扩展特征启用寄存器（`EFER`）中设置和取消设置`SCE`标志，可以有效地打开和关闭该机制。在未设置SCE标志的情况下使用`SYSCALL`或`SYSRET`会导致无效的操作码异常。

因此，**强制此机制导致系统中断是取消设置SCE标志**, 并将虚拟机管理程序设置为**捕获所有无效操作码异常**的问题，虚拟机扩展本身支持这些异常。一旦控制权转移到管理程序，我们必须再次区分自然例外和由我们内省引起的例外。这是通过查看违规指令来实现的，如果该指令不是SYSCALL或SYSRET，我们将一个无效的操作码异常注入到客户操作系统并将控制返回给它。但是，如果违规指令实际上是SYSCALL，则Nitro会收集所需信息，模拟该指令，并将控制权返回给客户操作系统。

除了模拟SYSCALL指令外，Nitro还必须能够处理由SYSRET指令引起的异常并模拟该指令。这是因为对EFER所做的更改会影响SYSRET指令，其影响方式与它们影响SYSCALL指令的方式相同。因此，使用SYSRET指令也会导致无效的操作码异常，因此必须进行相应的处理。这样做，如果应用程序需要此信息，Nitro还能够收集调用的系统调用的返回值。